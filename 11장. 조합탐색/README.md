조합탐색(Combinatorial Search)탐색 : 주어진 범위를 설정하고 그 범위 내에서 원하는 답을 찾는 것.탐색을 하는 여러가지 방법들BFS, DFS, 최단거리, 분할정복, DP, 그리디, 이분탐색 등어떤 방법을 사용할 것인가?DP분할정복But 어떻게 풀어야할지 모르는 경우는? 혹은 이 방법을 사용할 수 없는 경우는?가장 원시적인 방법으로 풀 수 밖에 없습니다.완전 탐색모든 답을 다 만들어본다how? 여러 개의 선택으로 나누고 재귀호출탐색공간하나의 선택에 n개의 다음 선택지가 있을 경우 다음으로 넘어가는데 n배가 됩니다점화식으로 표현하면?기하급수적으로 증가한다조합탐색 : 완전탐색을 포함해, 유일한 크기의 탐색 공간을 뒤지면서 답을 찾아내는 알고리즘 조합탐색에는 여러가지 기법이 있으며, 기본적으로 최적해가 될 가능성이 없는 답들을 탐색하는 것을 방지하여 탐색을 효율적으로 하게 한다.조합탐색은 딱히 정해진 방법이 있는 것이 아니다책에서 다루는 최적화 기법은 2가지1. 가지치기(Pruning)탐색 과정에서 최적해로 연결될 가능성이 없는 부분들을 잘라냄2. 좋은 답을 우선적으로 찾아냄탐색의 순서를 바꿈, 탐욕법그림 11.22. 조합 탐색 기법들TSPp.167(완전탐색), p.319(동적계획법)6장과 9장의 TSP예제 코드를 살펴보고어떤 차이가 있는지 살펴보도록 합시다. 코드 11.1123456789101112131415161718192021222324252627282930313233343536373839const double INF = 1e200;const int MAX = 30;int n;double dist[MAX][MAX]; double best; void search(vector<int>& path, vector<bool>& visited, double currentLength){    int here = path.back();     if(path.size() == n){        best = min(best, currentLength + dist[here][0])        return;    }      for(int next = 0 ; next < n; next++){        if(visited[next]) continue;         path.push_back(next);         visited[next] = true;        search(path, visited, currentLength + dist[here][next]);        visited[next] = false;         path.pop_back();    }} double solve(){     int best = INF;    vector<bool> visited(n, false);    vector<int> path(1, 0);    visited[0] = true;    search(path, visited, 0);    return best;} Colored by Color Scriptercsbacktracking 이용Q. 6장의 코드와 차이점이 코드의 시간복잡도는 n!시간을 살펴봅시다.최적해보다 나빠지면 그만 두기1234567891011121314151617181920212223242526272829303132333435363738394041const double INF = 1e200;const int MAX = 30;int n;double dist[MAX][MAX]; double best; void search(vector<int>& path, vector<bool>& visited, double currentLength){    int here = path.back();        if(path.size() == n){        best = min(best, currentLength + dist[here][0])        return;    }        //간단한 가지치기 : 지금까지 찾은 답 이상일 경우 중단    if(best <= currentLength) return;     for(int next = 0 ; next < n; next++){        if(visited[next]) continue;         path.push_back(next);         visited[next] = true;        search(path, visited, currentLength + dist[here][next]);        visited[next] = false;         path.pop_back();    }} double solve(){     int best = INF;    vector<bool> visited(n, false);    vector<int> path(1, 0);    visited[0] = true;    search(path, visited, 0);    return best;} Colored by Color Scriptercs그림 11.2의 (a)시간은?얼마나 똑똑하게 가지치기를 할 수 있을까?! 휴리스틱(Heuristic)사람이 어림짐작으로 문제를 푸는 과정을 알고리즘으로 옮긴 것. 최적의 답을 찾진 못하지만, 어느 정도 현실에 가까운 답을 찾진 못하지만, 어느 정도 현실에 가까운 답을 빨리 찾기 위한 용도.어림으로 -> 좀 더 빨리 쳐낸다!'앞으로 < 최적 - 현재까지'앞으로 >= 최적 - 현재까지인 경우를 쳐내면됨!'앞으로'를 잘 예측해야한다남은 최단 경로의 길이보다 작거나 같아야함(과소평가, 낙관적인 휴리스틱)trade off단순한 휴리스틱 함수의 구현so how??문제를 단순한 형태로아직 방문하지 않은 도시들에 대해 인접한 간선 중 가장 짧은 간선의 길이를 더한다코드 11.21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859const double INF = 1e200;const int MAX = 30;int n;double dist[MAX][MAX];//각 도시에 인접한 간선 중 가장 짧은 것을 미리 찾아 둔다.double minEdge[MAX]; double best; //가장 단순한 형태의 휴리스틱double simpleHeuristic(vector<bool>& visited){    double ret = minEdge[0];     for(int i = 0; i < n; i++){        if(!visited[i])            ret += minEdge[i];    }    return ret;}void search(vector<int>& path, vector<bool>& visited, double currentLength){    int here = path.back();     if(best <= currentLength + simpleHeuristic(visited)) return;     if(path.size() == n){        best = min(best, currentLength + dist[here][0])        return;    }      for(int next = 0 ; next < n; next++){        if(visited[next]) continue;         path.push_back(next);         visited[next] = true;        search(path, visited, currentLength + dist[here][next]);        visited[next] = false;         path.pop_back();    }} double solve(){    //simpleHeuristic()을 위한 초기화    for(int i = 0; i < n; i++){        minEdge[i] = INF;        for(int j = 0; j < n; j++){            if(i != j) minEdge[i] = min(minEdge[i], dist[i][j]);        }    }    int best = INF;    vector<bool> visited(n, false);    vector<int> path(1, 0);    visited[0] = true;    search(path, visited, 0);    return best;} Colored by Color ScriptercsQ. minEdge[MAX]Q.simpleHeuristic(vector<bool>& visited)의 함수 내부를 해석해봅시다.결과를 살펴봅시다가까운 도시부터 방문하기best를 더 빨리 찾아내자!TSP 문제에서 가까운 도시부터 방문을 먼저하는 것이 좋은 답을 빨리찾아낼 수 있는 '확률'이 높아진다코드 11.3123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051const double INF = 1e200;const int MAX = 30;int n;double dist[MAX][MAX]; //각 도시마다 다른 도시들을 가까운 순서대로 정렬해 둔다.vector<int> nearest[MAX];double best; void search(vector<int>& path, vector<bool>& visited, double currentLength){    int here = path.back();     if(path.size() == n){        best = min(best, currentLength + dist[here][0])        return;    }     for(int i = 0; i < nearest[here].size(); i++){        int next = nearest[here][i];        if(visited[next]) continue;         path.push_back(next);         visited[next] = true;        search(path, visited, currentLength + dist[here][next]);        visited[next] = false;         path.pop_back();    }} double solve(){    //nearest 초기화    for(int i = 0; i < n; i++){        vector<pair<double, int> > order;        for(int j = 0; j < n; j++)            if(i != j)                order.push_back(make_pair(dist[i][j], j));        sort(order.begin(), order.end());        nearest[i].clear();        for(int j = 0; j < n - 1; j++)            nearest[i].push_back(order[j].second);    }    int best = INF;    vector<bool> visited(n, false);    vector<int> path(1, 0);    visited[0] = true;    search(path, visited, 0);    return best;} Colored by Color ScriptercsQ. nearest결과를 확인해봅시다.Q. 단순한 휴리스틱과 가까운 도시부터 방문하기를 둘 다 섞으면??지나온 경로를 이용한 가지치기지금까지 만든 부분 답을 검사해서 가치를 치는 방법그림 11.5here와 visited의 목록이 같은 상황에서 currentLength가 더 길다면?탐색의 각 단계에서 현재까지 만든 부분해에 간단한 조작을 가해 보고, 답이 더 좋아지면 탐색을 중단(... , ... , p , a , b , q , ... , here)라는 경로가 있을 때,p -> a -> b -> q에서p -> b -> a -> q라고 경로를 바꿔보고바꾼 경로에서 길이가 더 작아진다면 현재 state에서 탐색을 중단코드 11.412345678910111213//path의 마지막 4개의 도시 중 가운데 있는 두 도시의 순서를 바꿨을 때//경로가 더 짧아지는지 여부를 반환한다. bool pathSwapPruning(const vector<int>& path){    if(path.size() < 4) return false;     int p = path[path.size() - 4];    int a = path[path.size() - 3];    int b = path[path.size() - 2];    int q = path[path.size() - 1];     return dist[p][a] + dist[b][q] > dist[p][b] + dist[a][q];}Colored by Color ScriptercsQ. return 값이 true일 때는 무엇을 하고 false일 때는 무엇을 할까요Q. 이 함수를 어디에 넣으면 될까요Q. 탐색 공간의 크기를 절반 이하로 줄여주는 효과가 있다방금 구현한 코드는 현재 도시 이전의 두 도시만을 뒤집어봅니다... , p , a , b , q , ...에서a와 b를 바꾸었는데... , p , a , b , c , q , ... 로 바꾸고a, b, c 3개를 바꾸면?... , p , a , b , c , d, q , ... 로 바꾸고a, b, c, d 4개를 바꾸면?12345678910111213141516//시작 도시와 현재 도시를 제외한 path의 부분 경로를//뒤집어 보고 더 짧아 지는지 확인한다.bool pathReversPruning(const vector<int>& path){    if(path.size() < 4) return false;    int b = path[path.size() - 2];    int q = path[path.size() - 1];     for(int i = 0; i + 3 < path.size(); i++){        int p = path[i];        int a = path[i + 1];         if(dist[p][a] + dist[b][q] > dist[p][b] + dist[a][q])            return true;    }    return false;}Colored by Color Scriptercs해석해봅시다결과를 비교해봅시다.Q. 부분 경로 뒤집는 가지치기와 이전 가지치기(단순한 가치지기, 휴리스틱 가지치기, 가까운 도시 부터 방문하기)를 섞을 수 있을까요?MST 휴리스틱을 이용한 가지치기단순한 휴리스틱의 문제점그림 11.7(a)에서 단순한 휴리스틱이 선택하는간선들이 굵게 표시되었는데이 들 중 2번 선택되는 것이 있습니다.왜 그럴까요?좀 더 현실에 가까운 답을 계산하기 위해서 조금 더 제약이 있는 문제를 만들어봅시다.1. 한 간선은 최대 한 번만 선택할 수 있다.2. 선택하지 않은 간선을 모두 지웠을 때 그래프가 둘 이상으로 쪼개지지 않는다.현재 위치에서 시작해서 아직 방문하지 않은 정점들을 모두 방문하고, 시작점으로 돌아오는 경로MST123456789101112131415161718192021222324252627282930313233343536//코드 11.5 MST 휴리스틱의 구현 //상호 배타적 집합 자료 구조struct DistjointSet{    //n개의 원소로 구성된 집합 자료구조를 만든다.    DisjointSet(int n);    //here가 포함된 집합의 대표를 반환한다.    int find(int here);    //a가 포함된 집합과 b가 포함된 집합을 합친다.    bool merge(int a, int b);};//모든 도시 간의 도로를 길이 순으로 정렬해 저장해 둔다.vector<pair<double, pair<int, int> > > edges;//here와 시작점, 아직 방문하지 않은 도시들을 모두 연결하는 MST를 찾는다.double mstHeuristic(int here, const vector<bool>& visited){    //kruskal's MST    DisjointSet sets(n);    double taken = 0;    for(int i=0; i<edges,size(); i++){        int a = edges[i].second.first, b = edges[i].second.second;        if(a != 0 && a != here && visited[a]) continue;        if(b != 0 && b != here && visited[b]) continue;        if(sets.merge(a, b))        taken += edges[i].first;    }    return taken;}double solve(){    //edges 초기화    edges.clear();    for(int i=0; i<n; i++)        for(int j=0; j<i; j++)            edges.push_back(make_pair(dist[i][j], make_paie(i, j)));    sort(edges.begin(), edges.end());    //..생략..}Colored by Color Scriptercs메모이제이션 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748//남은 도시의 수가 CACHED_DEPTH 이하면 동적 계획법으로 바꾼다. const int CACHED_DEPTH = 5;//dp(here, visited)=cache[here][남은 도시의 수][visited]map<int, double> cache[MAX][CACHED_DEPTH + 1]; //here : 현재 위치//visited : 각 도시의 방문 여부//일 때, 나머지 도시를 모두 방문하고 시작점으로 돌아가는 최단 경로의 길이를 반환한다. double dp(int here, int visited){    //기저 사례 : 더 방문할 도시가 없으면 시작점으로 돌아간다.    if(visited == (1 << n) - 1) return dist[here][0];     //메모이제이션    int remaining = n - __builtin_popcount(visited);    double& ret = cache[here][remaining][visited];     if(ret > 0) return ret;    ret = INF;     //다음 도시를 하나씩 시도한다.    for(int next = 0; next < n; next ++){        if(visited & (1<<next)) continue;        ret = min(ret, dp(next, visited + (1<<next)) + dist[here][next]);    }    return ret;} void search(vector<int>& path, int visited, double currentLength){     ...    //기저 사례 : 남은 도시 수가 CACHE_DEPTH 이하면 동적 계획법으로 바꾼다.    if(path.size() + CACHE_DEPTH >= n){        best = min(best, currentLength + dp(path.back(), visited));        return;    }     ...} double solve(){    //cache 초기화    for(int  i = 0; i < MAX; i++){        for(int j = 0; j <= CACHED_DEPTH ; j++)            cache[i][j].clear();    }}Colored by Color Scriptercs코드 9.15와 비교해서 살펴봅시다.Q. Cache의 형태를 비교해봅시다.왜 이렇게 map의 2차원 배열로 만들었을까요?(??)Q. search에서 어떻게 dp로 넘어오는지 살펴봅시다.입력에 따른 시간을 살펴봅시다정리각종 최적화 기법p.421
